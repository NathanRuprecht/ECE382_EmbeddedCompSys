ECE382_Lab2 - Subroutines - "Cryptography"
==========================================

##Lab2 Purpose
A program that decrypts an encrypted message using a simple encryption technique.

####Basic Functionality:

Message and Key are given.

Message: 0xef,0xc3,0xc2,0xcb,0xde,0xcd,0xd8,0xd9,0xc0,0xcd,0xd8,0xc5,0xc3,0xc2,0xdf,0x8d,0x8c,0x8c,0xf5,0xc3,0xd9,0x8c,0xc8,0xc9,0xcf,0xde,0xd5,0xdc,0xd8,0xc9,0xc8,0x8c,0xd8,0xc4,0xc9,0x8c,0xe9,0xef,0xe9,0x9f,0x94,0x9e,0x8c,0xc4,0xc5,0xc8,0xc8,0xc9,0xc2,0x8c,0xc1,0xc9,0xdf,0xdf,0xcd,0xcb,0xc9,0x8c,0xcd,0xc2,0xc8,0x8c,0xcd,0xcf,0xc4,0xc5,0xc9,0xda,0xc9,0xc8,0x8c,0xde,0xc9,0xdd,0xd9,0xc5,0xde,0xc9,0xc8,0x8c,0xca,0xd9,0xc2,0xcf,0xd8,0xc5,0xc3,0xc2,0xcd,0xc0,0xc5,0xd8,0xd5,0x8f

Key: 0xac

####B Functionality:

Message and Key are given.  Key is multiple bytes long.

Message: 0xf8,0xb7,0x46,0x8c,0xb2,0x46,0xdf,0xac,0x42,0xcb,0xba,0x03,0xc7,0xba,0x5a,0x8c,0xb3,0x46,0xc2,0xb8,0x57,0xc4,0xff,0x4a,0xdf,0xff,0x12,0x9a,0xff,0x41,0xc5,0xab,0x50,0x82,0xff,0x03,0xe5,0xab,0x03,0xc3,0xb1,0x4f,0xd5,0xff,0x40,0xc3,0xb1,0x57,0xcd,0xb6,0x4d,0xdf,0xff,0x4f,0xc9,0xab,0x57,0xc9,0xad,0x50,0x80,0xff,0x53,0xc9,0xad,0x4a,0xc3,0xbb,0x50,0x80,0xff,0x42,0xc2,0xbb,0x03,0xdf,0xaf,0x42,0xcf,0xba,0x50,0x8f

Key: 0xacdf23
   
####A Functionality:

Message is given.  Key is not given.

Message: 0x35,0xdf,0x00,0xca,0x5d,0x9e,0x3d,0xdb,0x12,0xca,0x5d,0x9e,0x32,0xc8,0x16,0xcc,0x12,0xd9,0x16,0x90,0x53,0xf8,0x01,0xd7,0x16,0xd0,0x17,0xd2,0x0a,0x90,0x53,0xf9,0x1c,0xd1,0x17,0x90,0x53,0xf9,0x1c,0xd1,0x17,0x90
   
##Preliminary Design

With my flowchart (below), I pretty much resorted back to our days of raptor.  Raptor was extemely easy to just have the general idea of what needed to be done.  It helped me visualize the subroutines to call them and return certain values.  For the basic functionality, my flowchart showed a pretty straight way to make a successful code.

![alt text](https://raw.githubusercontent.com/NathanRuprecht/ECE382_Lab2/master/Flowchart_Lab2.JPG "Lab2 FLowChart")

#Code

##Pseudocode

The below pseudocode was made in python to simulate Lab02 to get the minimum functionality requirements.  The idea is that main initializes everything that is needed, while the subroutines do the decrypting.  One leve down, the subroutine "decrypt_message" is used to decrypt the entire message.  The way it does that is by going another level down into "decrypt_character" to decrypt the message byte by byte.

```
# ECE 382 - Embedded Systems i - Fall 2014
#
# Lab2 - Subroutines - Cryptography
#
# Author: C2C Nathan Ruprecht
#
# Pseudocode2 - Minimum requirements
#


def main():
    #ROM
    encrypted_message = 0xef, 0xc3,0xc2,0xcb,0xde,0xcd,0xd8,0xd9,0xc0,0xcd,0xd8,0xc5,0xc3,0xc2,0xdf,0x8d,0x8c,0x8c,0xf5,0xc3,0xd9,0x8c,0xc8,0xc9,0xcf,0xde,0xd5,0xdc,0xd8,0xc9,0xc8,0x8c,0xd8,0xc4,0xc9,0x8c,0xe9,0xef,0xe9,0x9f,0x94,0x9e,0x8c,0xc4,0xc5,0xc8,0xc8,0xc9,0xc2,0x8c,0xc1,0xc9,0xdf,0xdf,0xcd,0xcb,0xc9,0x8c,0xcd,0xc2,0xc8,0x8c,0xcd,0xcf,0xc4,0xc5,0xc9,0xda,0xc9,0xc8,0x8c,0xde,0xc9,0xdd,0xd9,0xc5,0xde,0xc9,0xc8,0x8c,0xca,0xd9,0xc2,0xcf,0xd8,0xc5,0xc3,0xc2,0xcd,0xc0,0xc5,0xd8,0xd5,0x8f
    key = 0xac
    length_message = len(encrypted_message)
    
    #initializing registers
    R5 = encrypted_message
    R6 = key
    R7 = length_message

    #calling subroutine to decrypt
    message = decrypt_message(R5, R6, R7)
    print(message)


def decrypt_message(R5, R6, R7):

    #initiate array to store message
    R12 =[]
    
    #make array list as long as the message
    for i in range(R7):
        R12.append(1)

    #decrypt message by decrypting each byte    
    for i in range(R7):
        R12[i] = decrypt_character(R5[i], R6)

    #return the decrypted message
    return R12
     
def decrypt_character(R5, R6):

    #xor message and key
    byte = hex(R5 ^ R6)
    return byte


if __name__ == "__main__":
    main()
```

The enxt bit of pseudocode was to simulate Lab02 in python to get the B Functionality.  The idea was similar to the minimum functionality but needed an additional register to have the length of the key.  It was given to us, but we still needed to keep track of it so we could increment through the encrypted message correctly.  Same idea applied about subroutines and breaking up the message to decrypt.

```
# ECE 382 - Embedded Systems i - Fall 2014
#
# Lab2 - Subroutines - Cryptography
#
# Author: C2C Nathan Ruprecht
#
# Pseudocode3 - B functionality
#


def main():
    #ROM
    encrypted_message = 0xef, 0xc3,0xc2,0xcb,0xde,0xcd,0xd8,0xd9,0xc0,0xcd,0xd8,0xc5,0xc3,0xc2,0xdf,0x8d,0x8c,0x8c,0xf5,0xc3,0xd9,0x8c,0xc8,0xc9,0xcf,0xde,0xd5,0xdc,0xd8,0xc9,0xc8,0x8c,0xd8,0xc4,0xc9,0x8c,0xe9,0xef,0xe9,0x9f,0x94,0x9e,0x8c,0xc4,0xc5,0xc8,0xc8,0xc9,0xc2,0x8c,0xc1,0xc9,0xdf,0xdf,0xcd,0xcb,0xc9,0x8c,0xcd,0xc2,0xc8,0x8c,0xcd,0xcf,0xc4,0xc5,0xc9,0xda,0xc9,0xc8,0x8c,0xde,0xc9,0xdd,0xd9,0xc5,0xde,0xc9,0xc8,0x8c,0xca,0xd9,0xc2,0xcf,0xd8,0xc5,0xc3,0xc2,0xcd,0xc0,0xc5,0xd8,0xd5,0x8f
    key = 0xac, 0xac
    length_message = len(encrypted_message)
    length_key = len(key)
    
    #initializing registers
    R5 = encrypted_message
    R6 = key
    R7 = length_message
    R8 = length_key

    #calling subroutine to decrypt
    message = decrypt_message(R5, R6, R7, R8)
    print(message)


def decrypt_message(R5, R6, R7, R8):

    #initiate array to store message
    R12 =[]
    
    #make array list as long as the message
    for i in range(R7):
        R12.append(1)

    #decrypt message by decrypting each byte    
    for i in range(0, R7, R8):
        R12[i] = decrypt_character(R5[i], R6)

    #return the decrypted message
    return R12
     
def decrypt_character(R5, R6):

    #xor message and key
    byte = hex(R5 ^ R6)
    return byte


if __name__ == "__main__":
    main()
```
##Debugging
Unlike Lab1, there were not test cases for Lab2.  We were given the encrypted message and key (when needed), but not the decrypted message.  Hopefully I did not just miss this on the website because this was big for me.  So I did not have a way to check if my code was correct....  What I ended up doing is putting quite a bit of effort into my python code to the point that I was very confident with it's output.  I used that as my answer key to check CCS.  Once my CCS code had the answer match up with my python answers, I considered that a job well done!  Hopefully my python code wasn't completely off too....

##Testing Methodology / Results
I'm definitely one of those people that will code a very small piece of the problem, test it, and if correct, I store it away and don't touch it.  I'll repeat that method until I have all the pieces of the puzzle!  My first thing to do was set up and make sure I was using subroutines correctly.  I followed the template given to us and just had the lowest subroutine return a value until I was back in main.  After that, I no joke just worked on converting my python pseudocde to assembly in CCS.  Once I tweaked everything and got rid of the errors, my CCS code seemed to work just fine.

##Observations and Conclusions
Biggest thing for me is I really need to find the time to get instructor help for more than just the minimum requirements.  My grade can't handle getting points off as much as it is with these labs...  With Lab02, it seemed like everything went fine.  I did not get B or A functionality.  Honestly I think it came down to time put towards the project and the lack thereof.  Python pseudocode is quite possibly the best thing ever.  Having the python code and just converting it over made things so much easier.

##Documentation
I (unfortunately) did not get any help on Lab02.  We had some in class time where our instructor hit some points, but I did not receive any outside help.
